# 背景与起源

Rust 语言的诞生可谓是计算机领域的一场伟大冒险。由 Graydon Hoare 于 2010 年创建，它的设计初衷是为了满足系统级编程的需求，并弥补 C++ 等语言的不足。在 Rust 的成长过程中，吸收了众多前辈语言的优点，同时摒弃了它们的一些痛点，使得 Rust 在系统编程领域脱颖而出。

# 优点与适用场景

Rust 语言以其强大的内存安全性、零成本抽象、并发性和不可变性而闻名。其独特的所有权系统使得程序员能够在不牺牲性能的前提下编写安全、并发的代码。这使得 Rust 在编写操作系统、嵌入式系统、网络服务以及特别是区块链领域表现出色。

# Rust 与区块链

在区块链应用中，Rust 的性能和安全性变得尤为突出，为区块链开发者提供了一个理想的编程语言选择，支持构建高效且安全的去中心化应用。项目如 StarkNet 和 Solana 等选择 Rust 作为智能合约的编程语言；用于以太坊应用程序开发的工具包 Foundry，也是由 Rust 语言编写的，可以快速、方便的完成依赖项管理、编译、运行测试、部署。这些都主要得益于 Rust 强大的性能和内存安全性……这些项目的选择证明了 Rust 在区块链生态中的卓越表现，为开发者提供了强大而安全的编程语言，促进了区块链技术的发展。通过利用 Rust 的特性，区块链应用得以更好地平衡性能和安全性的需求，为未来的去中心化世界奠定了坚实的基础。接下来，让我们投入这场关于 Rust 的奇妙之旅吧~

# 变量

Rust 中的变量可以分为可变变量和不可变变量，通俗来说，就是变量的值是否允许修改，如果在内存中给变量分配完值之后，可以根据需要来修改这个值，那它就是可变变量，反之，不允许这个值再发生变更，那就是不可变变量。前者很容易理解，变量的值在不同场景下会发生变化，它为编程提供了灵活性；后者，也有存在的道理，通过不可变的限制，提供了编程的安全性，特别是在多线程环境下，也减少了一些运行时检查，在一定程度上提升运行性能。

注意：这里提到的是否可变指的是变量的值，而非变量的数据类型。另外，不可变变量这个特性并不是 Rust 特有的，在 Java 中也有类似的概念，比如 String 类型就是不可变变量，当对不可变对象的值进行了类似的修改操作时，本质上是创建了新的对象，而不是修改了这个不可变变量的值。

比喻

举个简单的例子，假如有个叫 Ferris 的同学，从它出生起，身份证号就是不可变的，伴随 Ferris 的一生（不可变变量在其整个生命周期中都是不可变的），因为不可变，所以在有些场景下非常有用，比如可以在全国公安系统中准确的定位到一个人；但是，像家庭住址、性别（Nothing is impossible）、联系方式等这些，却有可能发生变化，这些变化对 Ferris 来说也许是非常有必要的。注：Ferris 是 Rust 社区的吉祥物，就是那个被煮熟的螃蟹🦀🙈

我们分别定义 2 个不同类型的变量，并尝试修改对应的值。

```rs
fn main() {
    // x 为可变变量，mut 即 mutable 的意思，该修饰符修饰的变量允许改变
    let mut x = 1;
    println!("x = {}", x); 
    x = 2;
    println!("x = {}", x);

    // y 为不可变变量，如果没有指定 mut，则 Rust 默认为不可变
    let y = 3;
    println!("y = {}", y);
    // 对不可变变量 y 重新赋值，Rust 编译器会给出 cannot assign twice to immutable variable y 的错误提示
    y = 4; 
    println!("y = {}", y);
}
```

