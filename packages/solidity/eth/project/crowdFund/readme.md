# 众筹项目

定义 IERC20 的接口

在众筹项目的设计中，通常会涉及到募集符合 ERC20 标准的代币。所以，首先需要定义一个 IERC20 接口，以确保与 ERC20 代币的兼容性。IERC20 接口规范会为与代币交互提供一套标准的方法，通常可以包括转账、余额查询、授权和转账授权等功能。这样，无论众筹项目中使用的具体 ERC20 代币是什么，只要它们遵循了 IERC20 的规范，众筹合约就能够无缝地与之交互。

声明转账函数

标准的 IERC20 接口通常提供转账、余额查询、授权和转账授权等方法来与任何遵循 ERC20 标准的代币进行互动。为了顺利筹集到代币，我们必须确保代币合约具备处理代币转账的功能。所以，这里我们先重点关注转账函数的声明：transfer 和 transferFrom

● transfer：方法允许代币的持有者将代币直接发送到另一个地址。

● transferFrom：方法则用于在代币持有者授权后，允许第三方（例如，我们的众筹合约）从持有者账户中转出代币到任意地址。

在众筹合约中，transferFrom 尤为关键，因为它使得合约能够在收到用户授权后，从用户账户中直接提取代币，进而完成筹资。

定义构造函数

在部署合约之前，我们需要明确我们将采用哪种 ERC20 代币进行资金筹集。因为该代币合约必须实现我们的 IERC20 接口，所以只要有代币合约地址，我们就可以使用 IERC20 来实例化该合约，从而实现与该合约的交互。

因此，合约的构造函数中需要包含一个参数，用于接收这个 ERC20 代币的地址。这样，一旦合约被部署，它就被配置为与指定的 ERC20 代币合作，增加了合约的灵活性和适用性。

对于该地址变量，我们可以使用 immutable 标记，这样它的值会在合约构造函数执行期间被设置一次，并且在之后不能被修改。这样做不仅减少了合约的存储成本，还提高了合约的安全性。

定义 Campaign 结构体

到目前为止，我们已经搭建好了 CrowdFund 合约的基本框架。接下来，我们需要添加一些发起众筹所需要的数据结构来存储相关信息。项目方为一个活动发起众筹，那么最简化定义的话，这个活动需要什么信息呢？核心信息包括：

1. 项目发起者：标识谁启动了众筹活动。
2. 目标金额：设定的筹资目标，用以衡量众筹成功与否。
3. 活动起始时间：定义众筹活动开始和结束的具体时间点。
4. 用户质押数目：记录参与者质押的代币数量。
5. 资金申领状态：标识项目方是否已经成功申领筹集到的资金。

我们可以定义一个结构体来存储这些信息。

为了标识和记录项目方发起的各个活动，我们需要引入一个变量 count 来记录已经发起的众筹活动数量。每次创建新的众筹活动时，count 的值增加 1，这样 count 既能表示当前活动的总数，也能作为最新活动的唯一标识符。通过这种方式，我们不仅能够追踪众筹活动的总数，还能为每个活动提供一个独一无二的标识符，从而简化活动的管理过程。

当涉及到一一对应的关系时，我们通常使用 mapping 来存储。在这里，我们可以定义一个从 uint256 到 Campaign 的映射。在可见性方面，我们选择 public，以便于查询。

定义 launch 函数

为了使项目方能够发起众筹活动，我们将定义一个名为 launch 的函数供其使用。这个函数允许用户创建新的众筹项目，并将相关信息记录在智能合约中。在发起项目时，项目方必须提供以下相关的信息：

● 众筹的目标金额
● 活动的开始时间
● 活动的结束时间

验证输入参数
在上一步中，我们已经定义了项目方需要提供的信息。但为了确保众筹活动的设置合理且可行，我们需要对输入的信息进行限制和验证。这一步骤可以通过在智能合约中使用 require 语句来实现，以确保所有输入的信息都满足我们的预设条件：

1. **活动开始时间的验证：** 活动的开始时间必须在当前时间之后，以给予项目方和投资者准备的时间。

require(startAt > block.timestamp, "开始时间必须在当前时间之后");

2. **活动结束时间的验证：** 活动的结束时间必须大于开始时间，这样才有一个明确的、有序的众筹时间框架。

require(endAt > startAt, "结束时间必须大于开始时间");

3. **活动持续时间的验证：** 为了确保众筹活动有一个合理的时间范围，我们需要验证活动的持续时间不仅符合逻辑，还要满足特定的条件，比如让活动的结束时间不会超过合约调用时刻加上 90 天的最大持续期限。

require(\_endAt <= block.timestamp + 90 days, "活动持续时间不能超过 90 天");

更新活动 ID

还记的我们之前定义的变量 count 吗？它不仅用于统计已经创建的活动总数，还作为每个新活动的唯一标识符。在每次创建新的众筹活动时，我们应该将 count 变量的值增加 1，这样可以确保每个活动都有一个独特的 ID，并且能够持续追踪平台上活动的数量。

生成新的众筹活动

当我们创建一个新的众筹活动时，首先需要做的是构造一个 Campaign 结构体实例，这个实例将包含所有关于该活动的关键信息，其中一部分信息已在参数给出，我们来看剩下的部分：

● 发起者：通过 msg.sender 获取，函数的调用者即为众筹活动发起者的用户地址。
● 已筹集金额：用户质押的金额初始设置为 0，表示活动开始时还没有筹集到任何资金。
● 资金申领状态：初始设置为 false，表示活动发起者尚未从合约中提取筹集到的资金。

接下来，我们将利用刚才通过增加 count 值所定义的活动 ID 来记录众筹活动的详细信息。这一步骤是通过将新的 Campaign 结构体实例与其对应的活动 ID 记录到 campaigns 映射，确保了每个众筹活动的信息都能被准确地存储和访问

触发事件

到现在为止，我们就已经完成了新众筹活动的创建。接下来，我们可以通过触发事件来公开宣布新众筹活动的成功创建。

> 在智能合约中，事件是一种用于合约与区块链外部世界通信的机制。当特定的事件被触发时，它会被记录在区块链上，外部应用程序如前端界面或服务器后台可以监听这些事件，从而做出相应的响应或处理。

定义事件

为了宣布新众筹活动的创建，我们首先需要在合约顶部定义一个事件，这个事件将携带所有关键的活动信息，如新活动的 ID、创建者地址、目标金额、开始和结束时间。

定义 cancel 函数

如果在活动开始前，项目方已经成功集齐资金或因各种因素需要取消活动，那么提供一个取消活动的功能就显得尤为重要。这样的功能不仅为项目方提供了更大的灵活性和控制权，也保护了投资者的利益，确保他们的资金不会被无端占用或冻结。

因此，我们可以在合约中设计一个允许项目方在活动开始前取消众筹活动的 cancel 函数。为了精确执行取消操作，首先必须明确识别出待取消的活动。这可以通过提供活动的唯一 ID 来实现，利用这个 ID，我们能够在 campaigns 映射中找到相应的活动结构体。

获取指定活动

首先，我们通过传入的 \_id 从 campaigns 映射中获取到指定的众筹活动。

在这一步骤中，我们通常使用 memory 关键字创建一个临时的 Campaign 结构体副本。这种方法不仅有助于节省 gas 成本，因为与存储（storage）类型的变量相比，memory 类型的变量在函数调用期间的生命周期结束后就会被清除，而不会永久占用链上存储空间。此外，通过在函数内部操作这个临时副本，我们可以避免对全局状态的不必要修改，从而增加合约的执行效率和安全性。

验证活动信息

在执行取消操作之前，我们需要进行几项关键的验证，以确保操作的合法性和合理性：

1. 验证操作者身份

首先，我们需要验证调用 cancel 函数的用户是否为众筹活动的发起者，因为只有活动的发起者才有权取消自己的众筹活动。

2. 验证活动状态

其次，我们需要确保众筹活动尚未开始。这是因为一旦活动开始，可能已经有投资者参与，取消活动将影响到这些投资者的利益。
可以通过比较当前的时间戳（block.timestamp）与活动的开始时间（campaign.startAt）

delete

在验证完活动信息后，我们可以利用 delete 关键字来从 campaigns 映射中删除指定的结构体。值得注意的是，我们之前通过获取的 campaign 变量

Campaign memory campaign = campaigns[_id]

仅仅是一个副本，存储在内存中，而非存储在区块链的永久存储中。因此，对这个副本所做的任何修改都不会影响到存储在 campaigns 映射中的原始数据。要想真正从合约的存储中移除一个众筹活动的记录，我们可以直接使用 campaigns[_id] 。

💡 对于结构体来说，这意味着所有的字段都会被设置为各自类型的默认值，例如数字类型字段被设置为 0，地址类型字段被设置为 0x0，布尔字段被设置为 false 等。

正如在发起活动时使用 launch 函数触发事件以公开宣布活动的开始一样，cancel 函数的结尾也应该触发一个事件来公开通知活动的取消。

在 Launch 事件中，需要传递多种信息以描述活动，而 Cancel 事件的处理更为简洁——我们只需要传入被取消活动的唯一标识符 id。

定义 pledge 函数

接下来，我们继续实现众筹活动的下一重要功能：允许用户参与众筹并向众筹合约质押代币。这一环节是众筹成功的关键，它不仅让项目方有机会达成其资金目标，也为投资者提供了支持心仪项目的途径。与前面的章节一样，我们将先从定义一个 pledge 函数开始：

1. 参数：

● 活动 ID：这是用户希望支持的众筹活动的唯一标识符
● 代币数量：这是用户打算质押的代币数量。

2. 访问修饰符：由于不同的用户将通过区块链交易来调用这个函数参与众筹，因此使用 external 修饰符标记 pledge 函数。
   这表明该函数预期从合约外部被调用，优化了函数的 Gas 消耗，因为 external 函数能够直接访问调用数据。

获取指定活动

在正式进行质押之前，我们首先需要获取用户指定要质押代币的众筹活动项目。

这一步骤通过在 campaigns 映射中查询来实现，我们通过传入的活动 ID 来获取对应的 Campaign 结构体。不同于之前仅创建副本的做法，此时，我们使用 storage 关键字。

> storage 变量指向区块链的永久存储，任何对 storage 变量的修改都会直接反映在链上，并且是永久性的。

通过使用 storage，我们对 campaign 的任何修改都会直接影响到 campaigns 映射中存储的原始 Campaign 结构体。这样，当用户执行质押操作时，我们可以直接更新活动的已筹集金额等相关状态，确保数据的一致性和准确性。

验证时间信息

接下来，为了确保众筹活动的规范进行，我们必须对活动时间进行验证，确保用户只能在活动的有效期间内进行代币质押。

1. 验证活动是否已开始：确保当前时间已经超过活动的开始时间，这保证了用户只能在活动开始后进行质押。

可以通过比较当前的区块时间戳（block.timestamp）与活动的开始时间

2. 验证活动是否未结束：同样，我们需要确保当前时间还未到达活动的结束时间，从而保证用户不能在活动结束后进行质押。

定义 pledgedAmount 映射

为了详细记录每位用户对每个众筹活动的质押金额，我们可以定义一个双层映射来存储这些关键信息。这个映射的结构允许我们准确追踪和管理每个用户对不同众筹活动的质押情况。

mapping(uint256 => mapping(address => uint256))

● 外层映射：以众筹活动的唯一标识符（活动 ID）为键，指向另一个映射。这使得我们能够快速访问到与特定众筹活动相关的所有用户质押信息。

● 内层映射：以用户的地址为键，质押金额（以代币数量表示）为值。这层映射存储了每个用户对该活动的具体质押金额，使得合约能够为每位用户和每个活动维护一个独立的质押记录。

更新数据

在正式进行代币转账之前，我们首先需要更新与众筹活动相关的质押数据从而确保所有的信息都是最新的，同时也为即将发生的代币转移做好准备。具体来说，我们需要执行以下操作：

1. 更新活动的已筹集金额：将用户质押的代币数量累加到指定众筹活动的已筹集金额上。
2. 记录用户的质押金额：更新用户对特定众筹活动的质押总额。这不仅有助于跟踪每个用户对各个活动的质押情况，也为后续的退款或奖励分配提供了必要的数据支持。

转账

因为我们使用的是符合我们定义的 IERC20 接口的代币，该接口包含了转账函数，所以我们可以直接调用其中的 transferFrom 函数。通常，这个函数接受三个参数：发送方地址、接收方地址和转移金额。这使得我们能够从用户账户中安全地转移代币到众筹合约中，作为对特定活动的质押。

function transferFrom(address, address, uint256) external returns (bool);

transferFrom 方法通常用于从一个账户向另一个账户转移代币，且需要事先获得代币持有者的授权。

定义并触发事件

同样，在 pledge 函数执行的最后，为了通知外部监听器关于质押操作的成功执行，我们必须定义一个事件，然后在质押逻辑成功完成后触发它。

在合约的顶部定义一个名为 Pledge 的事件，用于在每次用户成功质押代币时发出通知。这个事件应该包含这些参数，如众筹活动的 ID、质押者的地址以及质押的金额。

而在 pledge 函数逻辑执行完毕，即用户的代币成功转移到合约并且所有相关信息更新之后，我们需要触发 Pledge 事件，将质押的详细信息广播出去。

定义 unpledge 函数

正如项目方可以在活动开始前取消众筹活动一样，用户也应该有机会在活动结束前撤销他们对项目的质押，无论是因为他们改变了主意还是需要回收资金。因此，我们可以设计一个 unpledge 函数来让用户取消质押，在这个函数中，用户只需要提供这样两个参数：

● \_id：这个参数指定了用户希望撤销质押的指定的众筹活动。

● \_amount：表示用户希望从质押中撤回的代币数量，允许用户有选择性地撤销部分或全部质押。

获取指定活动并验证

还记得在上一章节中，我们的质押函数是如何获取指定众筹活动的吗？我们通过创建一个 storage 类型的副本来实现。在这里，我们使用同样的方法获取用户要取消质押的活动。并且，为了我们需要确保只有在活动尚未结束时，用户才能撤销质押。这里我们仍然像质押函数中验证时间的方法一样，使用 require 语句。

更新数据并转账

在处理用户撤销质押的函数中，我们首先需要更新众筹活动的已筹集金额以及用户对该活动的个人质押记录，然后将相应的代币数量退还给用户。具体操作如下：

1. 更新活动的已筹集金额：我们从指定众筹活动的已筹集金额中减去用户撤销质押的代币数量。

2. 更新用户的质押记录：减少用户对该活动的质押总额。

3. 退还代币给用户：将指定数量的代币从众筹合约账户转移回用户账户的操作。这一步骤完成了撤销质押的过程，确保用户能够收回他们之前质押的资金。

transfer 方法直接从合约账户向指定的用户账户转移代币，不需要用户的事先授权。在用户撤销质押的情况下，合约已经持有了用户之前质押的代币，因此直接使用 transfer 方法将代币退还给用户更为简单和直接。

定义并触发事件

与我们之前的函数处理流程保持一致，我们需要定义并触发一个专门用于记录取消质押操作的事件。回忆一下，怎么定义事件并触发事件呢？

定义 claim 函数

在众筹活动成功结束后，项目方应被允许提取筹集的资金，以便推进项目发展。为此，我们需要提供一个提款函数，使项目方在输入活动 ID 后，只要满足特定条件，能够安全地提取指定众筹活动中筹集的资金。

获取指定活动并验证

相信你现在已经对我们获取指定众筹活动并进行验证的流程非常熟悉了。接下来，我们将通过 storage 关键字获取指定活动的引用，并利用 require 语句来验证该活动是否满足以下条件，以确保项目方可以安全地提取众筹活动中筹集的资金：

1. 活动已结束：首先，我们需要验证众筹活动是否已经结束。

这可以通过比较当前时间（block.timestamp）与活动结束时间来实现。只有当当前时间超过活动的结束时间时，项目方才有资格提取资金。

2. 筹资目标已达成：其次，需要确认众筹活动是否成功达到或超过了其筹资目标。这通过比较活动的已筹集金额与筹资目标来验证。

3. 资金未被提取：为了防止资金被重复提取，我们还需要确认这些资金尚未被项目方提取。

这可以通过检查活动的状态标记 campaign.claimed 来实现。

更新数据并转账

在确认众筹活动已成功结束，并且项目方满足了提取资金的所有条件之后，接下来的步骤是正式将筹集的资金转移给项目方，并更新活动的状态以反映资金已被提取：

1. 标记资金已被提取：首先，我们将活动的 claimed 状态设置为 true，这表示筹集的资金已经被项目方成功提取，防止资金被重复提取。

2. 执行资金转移：然后，使用 transfer 方法将筹集的资金从合约账户转移到项目方的账户。这里，campaign.creator 是接收资金的项目方地址，而 campaign.pledged 是需要转移的代币数量，即众筹活动成功筹集的总金额。

通过执行这两个步骤，我们可以确保了众筹活动的筹资目标一旦达成，项目方就能及时获得所需资金以推进项目发展，同时也更新活动状态防止项目方多次申领。

更新数据并转账

与我们之前的函数处理流程保持一致，我们需要定义并触发一个专门用于记录项目方已提取筹集资金的事件。回忆一下，怎么定义事件并触发事件呢？

定义 refund 函数

当众筹活动结束却未能达到既定的筹资目标时，众筹合约应该提供一个退款函数允许参与质押的用户取回他们投入的资金。这一过程不仅保障了投资者的利益，也增强了平台的信誉，确保了即使在不成功的众筹尝试中，用户的资金仍然得到妥善处理。

获取指定活动

同样的，我们首先需要获取指定的众筹活动信息。与之前的操作不同，这里我们采用 memory 关键字来创建活动信息的临时副本。由于后续的操作不涉及到活动信息的修改，采用这种方式可以更加节省 gas 成本。

验证信息

接下来，我们对活动信息进行验证，确保活动已经结束，并且筹集的金额未达到设定的目标。这一步骤是退款流程中至关重要的，它保证了只有在活动未能成功达成其筹资目标时，参与者才能够申请退款。

更新数据并转账

现在，我们开始执行用户的退款程序。首先，我们需要通过访问 pledgedAmount 映射，我们检索出用户在特定众筹活动中的质押金额。接着，为了确保不会发生重复退款的情况，我们将用户在该活动中的质押记录置为零。最后，我们执行代币退款操作，通过调用 transfer 函数将之前质押的代币数量退还给用户，完成整个退款流程。

定义并触发事件

与我们之前的函数处理流程保持一致，我们需要定义并触发一个专门用于记录退款操作的事件。回忆一下，怎么定义事件并触发事件呢？

部署

```sh
pnpm remixd -s ./eth/project/crowdFund -u https://remix.ethereum.org
```
