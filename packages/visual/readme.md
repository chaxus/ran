# GLSL 语法

## 变量

格式是：`变量类型` `变量名`=`值`;

需要注意的是：浮点型变量必须要有小数点，不能省略！而且语句结尾一定要加一个分号`;`

### 一维变量 (标量)

#### 浮点

```glsl
float foo=1.;
```

#### 整型

```glsl
int foo=1;
```

#### 布尔型

```glsl
bool foo=true;
bool bar=fragCoord.x<iResolution.x*.25;
if(bar){
    fragColor=vec4(color1,1.);
}
```

### 高维变量 (向量)

```glsl
vec2 a=vec2(1.,0.);
vec3 b=vec3(1.,.5,0.);
vec4 c=vec4(1.,.5,0.,1.);
```

vec 类型支持 3 种维度：二维 vec2、三维 vec3 和四维 vec4，四个维度分别为 x、y、z、w（也可以写为 r、g、b、a）。如果想对多维度变量进行取值或赋值操作，就要用到`.`符号，并且四个维度可以任意组合（称为 Swizzling）。

```glsl
vec2 d=b.xy;// d的值为vec2(1.,.5)
d.y=2.;// d的值为vec2(1.,2.)
vec3 e=c.yxy;// e的值为vec3(.5,1.,.5)，c.yxy可以理解为vec3(c.y,c.x,c.y)
e.zx=vec2(1.);// e的值为vec3(1.,1.,1.)
```

除了 vec 类型有更高的维度支持外，mat 类型（也就是矩阵类型）亦是如此。mat2 类型代表了一个大小是 2x2 的矩阵，mat3 类型则代表了一个 3x3 的矩阵、mat4 类型是 4x4 的矩阵。

```glsl
mat2 m1=mat2(1.,0.,0.,1.);
mat3 m2=mat3(1.,2.,0.,0.,0.,1.,2.,1.,0.);
mat4 m3=mat4(1.,2.,1.,0.,1.,1.,1.,0.,0.,0.,0.,1.,0.,1.,0.,1.);
```

如果想把多个变量捆绑到一个变量上，可以使用结构体 struct，它的使用方式如下所示（注意定义语句末尾要加分号）：

```glsl
struct ray{
    vec3 ro;
    vec3 rd;
};

void mainImage(out vec4 fragColor,in vec2 fragCoord){
    ray a;
    vec3 ro=vec3(0.,0.,1.);
    a.ro=ro;
    a.rd=vec3(0.,0.,2.);
    fragColor=vec4(a.ro,1.);
}
```

最后是一个小知识点：在创建变量时，我们也可以先声明变量，然后再对它进行赋值操作，并且赋值是从右到左进行的，因此，我们可以同时给多个变量赋予同一个值。

```glsl
float a,b,c,d;
a=b=c=d=3.;
```

## 运算符

算数运算符：用于执行基本的四则运算。

```glsl
float a=3.;
float b=2.;
float c=a+b;// c的值为5.
float d=a-b;// d的值为1.
float e=a*b;// e的值为6.
float f=a/b;// f的值为1.5
```

赋值运算符：用于将值赋给变量，赋值时也可同时进行算数运算。

```glsl
float a,b,c,d;
a=b=c=d=3.;
float k=2.;
a+=k;// 等同于a=a+k;a的值为5.
b-=k;// 等同于b=b-k;b的值为1.
c*=k;// 等同于c=c*k;c的值为6.
d/=k;// 等同于d=d/k;d的值为1.5
```

除此之外，还有比较运算符（>、<、==等）、逻辑运算符（&&、||、! 等），由于这些运算符在常规的编程语言中都普遍存在，这里就不再赘述了。

唯一要注意的一点是：运算一定要保证维度的匹配，比如你不能将一个 vec2 的变量与一个 vec3 的变量相加，要加的话你得选取 vec3 变量的其中 2 个维度，转成 vec2 变量才能与另一个 vec2 变量相加。

当然，也有一种特殊的情况：当一个向量和一个标量进行运算时，GLSL 会将标量广播（broadcast）到向量的每一个分量上。

```glsl
vec2 a=vec2(1.);
a-=.5;// a的值为vec2(.5)
```

## 函数

当你想复用一个代码片段时，定义一个函数就行，格式如下：

```glsl

float add(float a,float b){
    return a+b;
}

float c=add(1.,2.);// c的值为3.
```

一个函数包括返回类型（无返回类型为 void）、函数名、带类型的参数和返回值（可选）。调用函数时也要严格遵循定义好的类型。

当然，GLSL 本身也内置了相当多的函数，在以后的学习中我们会逐渐地碰到它们。

## 控制流

和常规的编程语言一样，GLSL 有一些基本的控制流结构。

条件语句 if，可以根据条件来执行不同的代码块。

```glsl
if(condition){
    // ...
}else if(anotherCondition){
    // ...
}else{
    // ...
}
```

这里要注意一点：Shader 是针对整个屏幕的像素进行处理的，因此 if 的所有分支只要满足一定的条件，都会被执行，也就是说，某一个分支对于其中一个点无效，那对应除了这个点之外的其他点可能就有效了。

循环语句 for，可以用来重复执行一段代码。

```glsl
for(int i=0;i<8;i++){
    // repeat ...
}
```

此外，还有 while、do-while、switch 这些常规的编程语言都支持的语句，这里就不再赘述了。

## 变量限定符

变量限定符是用来描述变量的存储和使用方式的关键词。

它的书写格式是`变量限定符` `变量类型` `变量名;`，语句结尾要加分号，例如：

```glsl
uniform vec3 uColor;
```

以上代码声明了一个 uniform 类型的名为 uColor 的 3 维向量。

在 GLSL 中，常用的变量限定符有以下几种：uniform、const、varying、attribute 等。

目前我们先要了解 uniform 和 const，其他的我们以后会碰到。

### uniform

uniform 变量是一种全局的变量，一旦定义后会同时存在于顶点着色器与片元着色器中，并且它在每一个顶点和片元上的值都是相同的，是一个“统一”的值。

在我们目前的 Shader 创作环境中，有一些内置的 uniform 变量可供我们直接使用，无需显式地去声明它们。

要注意的一点是：以后在 three.js 环境下，这些变量就不是内置的了，需要手动地去注入和声明。

### iTime

iTime 变量表示 Shader 从开始到现在执行所经过的时间。

如果要创作动画效果，这个变量可以说是必备的。

### iResolution

iResolution 变量表示 Shader 所在画布的大小，默认是占满整个屏幕。

有时我们可能会根据屏幕的比例对 Shader 的坐标进行适当的调整。

### iMouse

iMouse 变量表示用户鼠标当前所在的位置。

如果要创作可交互的效果，这个变量也是必备的。

### const

const 定义的量是一种常量，它是无法被改变的一个值。

```glsl
const float PI=3.14159265359;
```

以上代码定义了一个浮点型的常量 PI，值为 3.14159265359，其实就是圆周率。

## 宏

宏（macros）是一种预处理指令，用于在编译时进行文本的替换，常用于定义常量、函数、条件编译等。

宏定义的格式是`#define` `宏的名称` `宏的值`，语句结尾没有分号。

```glsl
#define PI 3.14159265359
```

以上代码定义了一个名为 PI 的宏，Shader 编译时会将所有的 PI 替换为 3.14159265359 这个值，可以类比为 JS 的 String.replace 这个函数。

宏也可以带有参数，如下所示：

```glsl
#define add(a,b) a+b
```

以上代码定义了一个名为 add 的宏，接受 2 个参数 a 和 b，对它们应用相加的运算，并且无需指定明确的类型，调用这个宏时只要参数的类型相匹配，就能正确执行宏定义的运算。

宏也可以条件编译，例如：

```glsl
#define IS_IN_SHADERTOY 1

#if IS_IN_SHADERTOY==1
#define iChannel0Cube iChannel0
#endif
```

这个宏的#if 部分会判断 IS_IN_SHADERTOY 这个宏的值是否为 1，是的话就会将下面的一行宏代码#define iChannel0Cube iChannel0 包含到 Shader 代码中去，不是的话就忽略掉这行宏代码。

需要注意的是，宏定义是一种文本替换机制，并没有类型检查和作用域限制，因此要根据实际的情况来使用它。




