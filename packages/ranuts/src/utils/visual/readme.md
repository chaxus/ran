在业务持续演进的过程中，遭遇了高度定制化图表的需求。为了寻找解决方案，首先深入探索了现有的开源图表库，遗憾的是，这些库虽能覆盖大部分功能需求（约 90%），但在满足特定定制化设计上却显得力不从心，那至关重要的 10% 缺口难以通过直接应用现有方案来填补。

为了精准复现设计愿景，我转而采用 canvas 技术手动绘制图表。这一过程中，尽管已尽力通过函数式编程范式封装和模块化绘制逻辑以提升代码的可维护性，但 canvas 的命令式特性在面临需求变动时，仍易导致直接而频繁的代码调整，影响了整体的开发效率和灵活性。

鉴于此，意识到，需要从更高层次的业务逻辑和设计理念出发，构建一个更为底层且灵活的图表绘制引擎。这样的引擎应能够抽象出绘制操作的核心要素，不仅服务于当前应用层的定制化需求，更应具备良好的扩展性和复用性，以便在未来面对更多样化的业务场景时，能够迅速响应并高效实现定制化图表的绘制需求。这样的策略转变，旨在从根本上提升图表定制化的开发效率和图表的维护性，确保业务迭代的顺畅进行。

# 一。技术设计

针对常见的绘制需求进行详尽的功能分析后，我们系统性地规划了高效且灵活的图表绘制引擎的核心构成要素。这些精心设计的组件旨在确保引擎不仅能够灵活应对多样化的定制需求，还具备出色的可维护性和可扩展性。具体而言，设计蓝图涵盖以下关键方面：

1. **基础图形库：**构建一个丰富的基础图形类库，提供便捷的 API 来绘制常见的几何形状，如矩形、圆形、多边形、曲线等。这些基础图形应支持自定义样式和属性，以满足多样化的设计需求。
2. **层级管理：**构建一个清晰的层级结构是绘制引擎的基础。这包括定义元素之间的堆叠顺序，如确保文字总是绘制在图表的上方，以及处理不同图表或元素之间的层级关系。层级管理将确保视觉呈现符合预期，即使在复杂的布局中也能保持清晰有序。
3. **图形组的管理：**引入节点和组的概念，允许用户将多个图形元素组织成一个整体（即“组”）。这样的设计使得对组进行整体移动、缩放或变形时，组内所有元素都能同步响应，大大简化了复杂场景下的操作和管理。
4. **变换矩阵：**对一个图形组执行平移、旋转、缩放等变形操作，从而以动态和灵活的方式调整图形的展示效果。为了实现这些变形操作，变形操作类通常会采用矩阵变换的原理。通过维护一个变换矩阵，并在绘制图形组之前应用该矩阵，可以一次性完成所有变形操作的计算，从而提高绘制效率。
5. **事件系统：**集成一个高效的事件处理系统，允许用户将事件监听器绑定到单个图形元素或整个组上。这样，无论是用户交互（如点击、拖动）还是系统事件（如加载完成、数据更新），都能得到及时响应和处理。
6. **应用层封装：**在应用层，我们需要封装绘制引擎提供的底层功能，使其更加贴近业务需求。这包括提供易于使用的 API 接口、优化性能、处理异常和错误等。同时，通过持续的应用层反馈，不断优化和调整绘制引擎，确保其能够更好地服务于业务的发展。

在上述绘制引擎架构中，各架构设计存在明确的依赖链：基础图形支撑图形组与层级管理；图形组与层级管理又是变换矩阵与事件系统的基础；最终，所有组件共同作用于应用的呈现，确保高效协同与用户体验。

# 二。基础图形库：

常见的基础图形有：
1. 圆
2. 椭圆
3. 多边形
4. 矩形
5. 圆角矩形

先实现一个基础类，然后其他的所有图形类都继承这个抽象类：

```ts
export abstract class Shape {
  // 支持的所有几何图形都会继承自这个 Shape 基类
  public abstract type: ShapeType;
  constructor() {}
}
```

其中`ShapeType`目前有以下几个属性：

```ts
// 支持的形状类型
export enum ShapeType {
  Rectangle = 'rectangle',
  Polygon = 'polygon',
  Circle = 'circle',
  Ellipse = 'ellipse',
  RoundedRectangle = 'rounded rectangle',
}
```

## 1.圆



## 1。层级和节点

层级的管理非常简单，在 canvas 绘图环境中，先绘制的图形会被后绘制的图形所覆盖，因此，层级的管理就自然地通过绘制顺序来实现。在这种情况下，最先被绘制的图形将位于最底层，而随后绘制的图形则逐层叠加，直至最上层。




