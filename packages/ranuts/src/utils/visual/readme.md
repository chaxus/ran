## 一。层级和节点

canvas 并不会主动维护一个层级关系，我们能做的事情，只有画圆、画矩形、画线等，至于像 DOM 那样，在一个节点上调用 appendChild 来给这个节点添加子节点这种事情，在 canvas 里是不存在的，canvas 根本就没有所谓的元素 (或者说是节点) 这个概念，更没有所谓的层级关系的概念，canvas 开发注定不能像 DOM 那样方便，随意地在节点上添加子节点，或者删除子节点，以及让节点成组。

我们肯定不希望用这么底层的 API 进行业务开发的，想象一下，我现在画了一个图形 A，这个图形 A 包含若干个子图形，现在我想让这个图形 A 旋转 90 度，注意，是作为一个整体旋转 90 度，要保证各个子图形之间的相对位置不变，也就是让这一系列的子图形成一个组，我需要分别计算每一个子图形旋转 90 度的位置，而且为了保证旋转后这些子图形的相对位置保持不变，我需要设置一个旋转的锚点，也就是图形 A 的左上角，以上的步骤是非常繁琐的，作为业务开发，我不希望这么麻烦，我希望的是只需要调用一个 API(就像 element.style.transform='rotate(90deg)') 就能完成这件事了，然后剩下的事情交给渲染引擎来做就行了。

### 1. 规划

#### (1).节点

我们会在 canvas 中实现类似 DOM 节点的概念，用简单的 API 修改节点的某些属性，就可以在页面上直接看到效果，就像操作 DOM 一样。

#### (2).父子节点层级

如同 DOM 树一样，我们要实现的渲染引擎里，父节点和子节点之间也会形成一棵树状结构。

在 DOM 里，子节点不一定参照父节点来进行定位，而是可能有多种定位方式，(position:fixd，position:absolute，position:static 等)，但是在我们要实现的渲染引擎里，我们不需要实现那么复杂的定位，让子节点完全依赖父节点来进行定位就 OK 了 (类似于 position:static)。

在 DOM 里，子节点一定会位于父节点的上面，我们要做的渲染引擎也是如此，具体实现方式是：在执行渲染逻辑的时候，父节点会先被渲染出来，子节点在之后才会被渲染，这样就实现了子节点在父节点之上的效果。

#### (3).兄弟节点层级

我们将会用一个数组来保存兄弟节点，和 DOM 类似，我们会实现一个 z-index 属性来控制哪些节点被放在顶层，哪些节点被放在下面。

我们只会在兄弟节点之间进行 z-index 的比较，而不会在祖先节点和子节点之间进行 z-index 的比较。

在执行渲染逻辑之前，我们会对这个数组进行排序，z-index 越大的节点会被排在数组的越后面，这意味着 z-index 越大的节点会在越后面进行渲染，这样我们看到的效果就是 z-index 大的节点会被放在顶部。

#### (4).组的概念

在 DOM 里，祖先节点和其包含的所有子节点会形成一个组，在对祖先节点进行旋转、平移、缩放时，其所有子节点也会旋转、平移、缩放，在这个渲染引擎里，我们要实现同样的效果。

#### (5).锚点

锚点就类似于 DOM 的 transform-origin 属性，在旋转或者缩放的时候，锚点会固定不变。在 canvas 中，一切变换都是线性的变换，大家可以理解为：在 canvas 中，缩放和旋转，都是将原点 (canvas 元素左上角) 作为锚点来进行的。这对于业务开发来说非常不便利，所以我们要实现类似于 DOM 的 transform-origin 属性，来提高效率。

### 2.实现

#### (1). Vertex

这个类代表了最原始的‘节点’的概念，所有可以被展示到 canvas 画布上的、各种类型的节点都会继承于这个类，这是一个抽象类，我们并不会直接实例化这个类。

这个类上面挂载了‘节点’的各种属性，比如：父元素、透明度、旋转角度、缩放、平移、节点是否可见等。

#### (2).Container

这个类代表了‘组’的概念，它提供了添加子元素，移除子元素等的方法；后续的要被渲染的一些类 (如 Graphics，Text，Sprite 等) 会继承于这个类；这个类本身不会被渲染 (因为它只是一个‘组’，它本身没有内容可以渲染)。

这个类继承于 Vertex 类，‘组’也算作‘节点’。

#### (3).Graphics

这个类会用来构建一些几何图形元素；它会继承 Container 类。

#### (4).Matrix 和 Transform

在渲染引擎中，一切变换 (平移、旋转、缩放等) 都会转化成变换矩阵 (matrix)，因为 canvas 只接受矩阵变换，虽然 canvas 为了开发的便捷，也提供了 ctx.rotate,ctx.scale 等操作，但是 canvas 中的这些操作会直接转换成变换矩阵，而不像 DOM 那样，有锚点的概念，所以 canvas 提供的 rotate，scale 等操作，和 DOM 提供的 rotate，scale 的表现是不一样的。

Matrix 类将会提供各种各样的与矩阵操作相关的函数 (矩阵相乘，矩阵求逆等)，任何变换的叠加都将会转换成 matrix，方便我们调用 canvas 的指令。

Transform 类就类似 CSS 的 transform，它提供了一些更清晰、更符合人类直觉的变换，而不用直接使用矩阵变换，当然，这些变换最终会转换成矩阵变换。

#### (5).Application

这是渲染引擎的入口，将 canvas 元素等参数传给这个类，然后这个类就会启动渲染引擎，开始渲染。

Application 类的 stage 属性是一个 Container，要把节点添加到 stage 上，渲染引擎才会渲染这些节点，stage 是一切待渲染元素的祖先元素。

### 3.操作
