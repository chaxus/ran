import{_ as t,c as a,o as i,al as s}from"./chunks/framework.CJQKKEpO.js";const m=JSON.parse('{"title":"Statistical execution time","description":"","frontmatter":{},"headers":[],"relativePath":"src/ranuts/utils/task.md","filePath":"src/ranuts/utils/task.md","lastUpdated":1768369275000}'),o={name:"src/ranuts/utils/task.md"};function n(r,e,d,c,l,h){return i(),a("div",null,[...e[0]||(e[0]=[s('<h1 id="statistical-execution-time" tabindex="-1">Statistical execution time <a class="header-anchor" href="#statistical-execution-time" aria-label="Permalink to &quot;Statistical execution time&quot;">​</a></h1><p>Sometimes, we need statistics on the execution time of a function to analyze performance. Therefore, the &#39;startTask&#39; and &#39;taskEnd&#39; functions are wrapped. Three other statistical methods are also introduced</p><ol><li><code>new Date().getTime()</code>,</li><li><code>console.time()</code> , <code>console.timeEnd()</code>,</li><li><code>performance.now()</code></li></ol><h2 id="i-starttask-taskend" tabindex="-1">I. <code>startTask</code>, <code>taskEnd</code> <a class="header-anchor" href="#i-starttask-taskend" aria-label="Permalink to &quot;I. `startTask`, `taskEnd`&quot;">​</a></h2><h3 id="_1-starttask" tabindex="-1">1. startTask <a class="header-anchor" href="#_1-starttask" aria-label="Permalink to &quot;1. startTask&quot;">​</a></h3><p>Execute before the task begins.</p><h4 id="return" tabindex="-1">Return <a class="header-anchor" href="#return" aria-label="Permalink to &quot;Return&quot;">​</a></h4><table tabindex="0"><thead><tr><th>Parameter</th><th>Description</th><th>Type</th></tr></thead><tbody><tr><td>taskId</td><td>Task identifier</td><td><code>unique symbol</code></td></tr></tbody></table><h3 id="_2-taskend" tabindex="-1">2. taskEnd <a class="header-anchor" href="#_2-taskend" aria-label="Permalink to &quot;2. taskEnd&quot;">​</a></h3><p>Execute when task ends, requires task identifier returned by <code>startTask</code>.</p><h4 id="options" tabindex="-1">Options <a class="header-anchor" href="#options" aria-label="Permalink to &quot;Options&quot;">​</a></h4><table tabindex="0"><thead><tr><th>Parameter</th><th>Description</th><th>Type</th><th>Default</th></tr></thead><tbody><tr><td>taskId</td><td>Task identifier</td><td><code>unique symbol</code></td><td>Required</td></tr></tbody></table><h4 id="return-1" tabindex="-1">Return <a class="header-anchor" href="#return-1" aria-label="Permalink to &quot;Return&quot;">​</a></h4><table tabindex="0"><thead><tr><th>Parameter</th><th>Description</th><th>Type</th></tr></thead><tbody><tr><td><code>time</code></td><td>Task execution time</td><td><code>number</code></td></tr></tbody></table><h3 id="_3-usage-example" tabindex="-1">3. Usage Example <a class="header-anchor" href="#_3-usage-example" aria-label="Permalink to &quot;3. Usage Example&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> taskId</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> startTask</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// do something</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> time</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> taskEnd</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(taskId);</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Task execution time:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, time);</span></span></code></pre></div><h2 id="ii-new-date-gettime" tabindex="-1">II. new Date().getTime() <a class="header-anchor" href="#ii-new-date-gettime" aria-label="Permalink to &quot;II. new Date().getTime()&quot;">​</a></h2><p><code>new Date().getTime()</code> returns a numeric value representing the number of milliseconds from January 1, 1970, 00:00:00 UTC (Coordinated Universal Time) to the time represented by the date object. There are two problems when using it to calculate JS execution time:</p><ol><li>In some cases, millisecond precision may not be sufficient.</li><li>The time parsed by <code>new Date()</code> may not be consistent across different browsers or devices. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date" target="_blank" rel="noreferrer">MDN Documentation</a><blockquote><p>Due to differences and inconsistencies between browsers, it is strongly recommended not to use the Date constructor to parse date strings (or use Date.parse which is equivalent). There is only conventional support for RFC 2822 format dates. For ISO 8601 format support, only date strings (e.g., &quot;1970-01-01&quot;) will be treated as UTC rather than local time, which differs from other format string handling.</p></blockquote></li></ol><h2 id="iii-console-time-console-timeend" tabindex="-1">III. <code>console.time()</code>, <code>console.timeEnd()</code> <a class="header-anchor" href="#iii-console-time-console-timeend" aria-label="Permalink to &quot;III. `console.time()`, `console.timeEnd()`&quot;">​</a></h2><p>Start a timer to track the duration of an operation. Each timer must have a unique name, and a page can run up to 10,000 timers simultaneously. When <code>console.timeEnd()</code> is called with the timer name as a parameter, the browser will output the elapsed time of the corresponding timer in milliseconds. Compared to <code>new Date().getTime()</code>, time statistics are more precise, can be accurate to 0.001 milliseconds (e.g., 0.134ms).</p><h2 id="iv-performance-now" tabindex="-1">IV. <code>performance.now()</code> <a class="header-anchor" href="#iv-performance-now" aria-label="Permalink to &quot;IV. `performance.now()`&quot;">​</a></h2><p><code>performance.now()</code> returns time with precision up to microseconds, and is not affected by system time (system clock may be manually adjusted or tampered with by NTP and other software). Additionally, <code>performance.timing.navigationStart + performance.now()</code> approximately equals <code>Date.now()</code>. Therefore, <code>performance.now()</code> is more recommended for statistics on JS execution time.</p><blockquote><p>Note: To provide protection against timing attacks and fingerprinting, the precision of <code>performance.now()</code> may be reduced based on browser settings. In <code>Firefox</code>, the <code>privacy.reduceTimerPrecision</code> preference is enabled by default with a default value of <code>1ms</code>. Enabling <code>privacy.resistFingerprinting</code> will change the precision to 100ms or the value of <code>privacy.resistFingerprinting.reduceTimerPrecision.microseconds</code>, whichever is larger.</p></blockquote>',24)])])}const u=t(o,[["render",n]]);export{m as __pageData,u as default};
