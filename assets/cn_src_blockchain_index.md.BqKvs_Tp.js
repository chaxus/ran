import{_ as e,c as p,o as t,al as r}from"./chunks/framework.CQmC_4em.js";const s="/ran/assets/blockchain.DJmrX8UH.webp",i="/ran/assets/blockchain-content.CmHz4_fp.webp",o="/ran/assets/blockchain-swap.D5C4r3T0.webp",c="/ran/assets/blockchain-tree.A7z-d9nO.webp",n="/ran/assets/blockchain-trip.c0zeNxFx.webp",l="/ran/assets/blockchain-end.BakOYMF8.webp",x=JSON.parse('{"title":"区块链数据结构","description":"","frontmatter":{},"headers":[],"relativePath":"cn/src/blockchain/index.md","filePath":"cn/src/blockchain/index.md","lastUpdated":1750482319000}'),h={name:"cn/src/blockchain/index.md"};function d(m,a,b,_,k,u){return t(),p("div",null,a[0]||(a[0]=[r('<h1 id="区块链数据结构" tabindex="-1">区块链数据结构 <a class="header-anchor" href="#区块链数据结构" aria-label="Permalink to &quot;区块链数据结构&quot;">​</a></h1><p>区块链作为 Web3 生态的核心基础设施，相当于一个分布式数据库，用于存储全球范围内的交易数据、智能合约、用户身份信息和各种类型的去中心化应用（dApps）数据。以太坊区块链从上往下可以依次分解为：区块链、区块、交易三个层次，其中的交易数据、收据数据、状态数据和账户数据都分别存储在四棵默克尔树中。如果你是第一次接触这些概念，不用担心。在这个章节，我们将以以太坊为例，为你逐层解析区块链的数据结构。</p><h2 id="区块链" tabindex="-1">区块链 <a class="header-anchor" href="#区块链" aria-label="Permalink to &quot;区块链&quot;">​</a></h2><p>区块链是一系列数据块（即“区块”），通过特定的方式相互连接，形成的一条链。每个区块都包含前一个区块的哈希值，称为“父哈希值”（Parent Hash），这是前一个区块内容的唯一标识符。通过这种方式，每个区块都与前一个区块相连接，形成了一条从第一个区块（创世区块）到最新区块的连续链条，这就是“区块链”。注：第一个区块里无父哈希值。</p><p><img src="'+s+'" alt=""></p><h2 id="区块" tabindex="-1">区块 <a class="header-anchor" href="#区块" aria-label="Permalink to &quot;区块&quot;">​</a></h2><p>区块链中的每一个区块，都由两个部分组成：区块头（Header）和区块体（Body）。</p><p>①区块头</p><p>区块头里包含了一个区块的基本信息，主要包括：</p><p>● 父哈希值（parentHash）：记录前一个区块的哈希值。</p><p>● 时间戳（timestamp）：记录区块创建的具体时间。</p><p>● 随机数（nonce）：用于工作量证明（PoW）机制中的挖矿过程。</p><p>● 难度目标（difficulty）：表示挖矿的难度。</p><p>● 币基（coinBase）：标识矿工的账户地址。</p><p>另外，区块头里还记录了三个非常重要的根哈希值：</p><p>●状态树根（stateRoot）：表示了区块链的状态树的根哈希值，状态树记录了所有账户的状态信息，如余额、合约代码等。</p><p>●收据树根（receiptRoot）：表示收据树的根哈希值，收据树记录了交易执行的结果，如交易是否成功、交易费用等。</p><p>●交易树根（transactionRoot）：表示交易树的根哈希值，交易树包含了区块中所有交易的信息。</p><p>②区块体</p><p>区块体里存储了该区块中的所有交易数据，即所有交易哈希的列表。</p><p><img src="'+i+'" alt=""></p><h2 id="交易" tabindex="-1">交易 <a class="header-anchor" href="#交易" aria-label="Permalink to &quot;交易&quot;">​</a></h2><p>在以太坊中，交易代表从一个账户向另一个账户发送资产或消息的行为。当用户发起一笔交易时，以太坊客户端或钱包软件将会构造交易数据。交易数据主要包含如下字段：</p><p>● nonce：发送方账户的交易计数器，统计该账户在此区块链中的总交易次数。</p><p>● gasPrice：发送方愿意为每单位 gas 支付的价格。</p><p>● gasLimit：发送方为这次交易设置的最大 gas 消耗量。</p><p>● to：接收方的账户地址。</p><p>● value：要传输的以太币数量。</p><p>● data：智能合约相关的字节码。</p><p>● v, r, s：交易签名，由发送方的私钥生成。</p><p>交易数据构造完成后，钱包将使用用户的私钥对整个交易进行签名，并将签名结果（v, r, s）加入交易数据中，然后对整个交易数据（不包括签名）计算哈希值，交易哈希是交易数据的唯一标识符，确保了交易的唯一性和不可篡改。</p><p>例如，Alice 想要发送 1 ETH 给 Bob，Alice 的账户地址是 0x123…ABC，Bob 的账户地址是 0x456…DEF。Alice 的账户已经执行过 5 笔交易，所以她的下一笔交易的 nonce 为 6。当前的 gas 价格是 20 Gwei，她设置的 gas limit 是 21000（标准以太坊转账所需的 gas 费）。Alice 不调用任何合约，所以 data 字段为空。</p><p>● nonce: 6</p><p>● gasPrice: 20000000000 (20 Gwei)</p><p>● gasLimit: 21000</p><p>● to: 0x456…DEF</p><p>● value: 1000000000000000000 (1 ETH)</p><p>● data: 0x</p><p>● v, r, s: [签名数据]</p><p>Alice 的钱包会把这些交易数据进行打包和签名，然后生成交易哈希，并将这个交易广播到以太坊网络。矿工将确认这笔交易并将其加入新区块，一旦成功，1 ETH 就会从 Alice 的账户转移到 Bob 的账户。</p><h2 id="交易收据" tabindex="-1">交易收据 <a class="header-anchor" href="#交易收据" aria-label="Permalink to &quot;交易收据&quot;">​</a></h2><p>在以太坊中，当一笔交易完成后，会生成“交易收据”（Transaction Receipt，又叫交易回执）。交易收据记录了交易执行的基本信息，是交易被包含在区块链中的重要证据。</p><p><img src="'+o+'" alt=""></p><p>每个交易收据包含的信息有：</p><p>● transactionHash：交易哈希值，用于唯一标识一笔交易。</p><p>● transactionIndex：交易在所在区块中的索引位置。</p><p>● blockHash：包含该交易的区块哈希值。</p><p>● blockNumber：包含该交易的区块编号。</p><p>● from：发起交易的地址。</p><p>● to：交易的目标地址。</p><p>● cumulativeGasUsed：当前区块中累积消耗的 Gas 量。</p><p>● gasUsed：这笔交易所消耗的 Gas 量。</p><p>● contractAddress：如果交易用于创建合约，则表示合约地址；否则为 null。</p><p>● logs：交易过程中产生的事件日志。</p><p>● logsBloom：布隆过滤器，用于快速检索交易日志。</p><p>● status：交易执行的状态码，表示成功或失败。</p><h2 id="默克尔-帕特里夏树-merkle-patricia-tree" tabindex="-1">默克尔 - 帕特里夏树 Merkle Patricia Tree <a class="header-anchor" href="#默克尔-帕特里夏树-merkle-patricia-tree" aria-label="Permalink to &quot;默克尔 - 帕特里夏树 Merkle Patricia Tree&quot;">​</a></h2><p>以太坊每天的交易量达到数百万笔，如此多的交易数据是如何存储的呢？这里采用了一种名为 Merkle Patricia Tree（MPT）的数据结构，这是一种特殊类型的默克尔树（Merkle Tree）。我们先了解一下基本的默克尔树。</p><p>①默克尔树，也称为哈希树（Hash Tree），这棵树的叶子节点是数据块的哈希值，非叶子节点是其子节点的哈希值串联后再次进行哈希计算的结果，这样可以确保数据的完整性。如图所示，节点值的计算方法为：</p><p>哈希 A=Hash (数据 A );</p><p>哈希 B=Hash (数据 B );</p><p>哈希 E=Hash (哈希 A+ 哈希 B );</p><p><img src="'+c+'" alt=""></p><p>②帕特里夏树（Patricia Trie），也称为压缩前缀树，这棵树既可以利用字符串的公共前缀来减少查询时间，又可以通过压缩无分支的节点来节省空间。</p><p><img src="'+n+'" alt=""></p><p>③默克尔 - 帕特里夏树（Merkle Patricia Tree）结合了默克尔树（Merkle Tree）和帕特里夏树（Patricia Trie）的优点，既可以验证数据的完整性，也可以快速检索状态信息，非常适合用作以太坊中的数据存储。在每个区块里，分别有一棵默克尔 - 帕特里夏树来存储交易数据、收据数据、状态数据和账户数据。</p><h2 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h2><p>这一小节，我们对以太坊区块链的数据结构有了一个基本了解，可以用下面一张图来总结，它是一种高度复杂且精妙的设计，它整个系统能够安全地记录和验证交易，同时保证了网络的去中心化特性。</p><p><img src="'+l+'" alt=""></p><blockquote><p>以太坊平台正在快速发展和持续升级，文章中的数据结构信息可能已不再是最新版本。另外，不同区块链之间的数据结构也会有所差异。所以我们强烈建议你关注最新的区块链技术动态，并以官方发布的最新文档为准确。</p></blockquote>',70)]))}const T=e(h,[["render",d]]);export{x as __pageData,T as default};
